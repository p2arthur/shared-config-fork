name: Release Python Package
author: mrcointreau
description: Run semantic-release for Python packages. Set pypi-publish=true for atomic release+publish (recommended). If PyPI fails, no tag/release is created

inputs:
  python-version:
    description: Python version
    required: false
    default: "3.12"
  working-directory:
    description: Working directory
    required: false
    default: "."
  bot-token:
    description: GitHub token for release
    required: true
  pypi-token:
    description: PyPI token for publishing, optional if using OIDC trusted publishing
    required: false
  dry-run:
    description: Run in dry-run mode
    required: false
    default: "false"
  use-oidc:
    description: Use OIDC trusted publishing (recommended), set to 'false' to use tokens
    required: false
    default: "true"
  config-path:
    description: Path to semantic-release config file (uses built-in config if empty)
    required: false
    default: ""
  pypi-publish:
    description: Publish package to PyPI during release (atomic release+publish)
    required: false
    default: "false"
  build-command:
    description: Build command to run
    required: false
    default: "uv build"
  dist-directory:
    description: Directory containing built package to publish (only used when pypi-publish is true)
    required: false
    default: "dist"

outputs:
  new-release-published:
    description: Whether a new release was published ('true' or 'false')
    value: ${{ steps.release.outputs.new-release-published }}
  new-release-version:
    description: The new release version (if published)
    value: ${{ steps.release.outputs.new-release-version }}
  new-release-git-tag:
    description: The git tag of the new release (if published)
    value: ${{ steps.release.outputs.new-release-git-tag }}

runs:
  using: composite
  steps:
    - name: Setup Node.js (for semantic-release)
      uses: actions/setup-node@6044e13b5dc448c55e2357c09f80417699197238 # v6.2.0
      with:
        node-version: "22"

    - name: Setup Python
      uses: actions/setup-python@a26af69be951a213d495a4c3e4e4022e16d87065 # v5.6.0
      with:
        python-version: ${{ inputs.python-version }}

    - name: Install uv
      uses: astral-sh/setup-uv@d4b2f3b6ecc6e67c4457f6d3e41ec42d3d0fcb86 # v5.4.2
      with:
        enable-cache: true

    - name: Install Dependencies
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      run: uv sync

    - name: Install semantic-release
      shell: bash
      working-directory: ${{ github.action_path }}
      run: npm ci

    - name: Run semantic-release
      id: release
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      env:
        GITHUB_TOKEN: ${{ inputs.bot-token }}
        USE_OIDC: ${{ inputs.use-oidc }}
        PYPI_TOKEN: ${{ inputs.pypi-token }}
        DRY_RUN: ${{ inputs.dry-run }}
        NODE_PATH: ${{ github.action_path }}/node_modules
      run: |
        # =============================================================================
        # STEP 1: Validate authentication
        # OIDC is preferred (no token needed), but if disabled, pypi-token is required
        # =============================================================================
        if [ "${{ inputs.dry-run }}" != "true" ] && [ "${{ inputs.use-oidc }}" != "true" ] && [ -z "${{ inputs.pypi-token }}" ]; then
          echo "::error::pypi-token is required when use-oidc is false (set PYPI_TOKEN or run with dry-run)."
          exit 1
        fi

        # =============================================================================
        # STEP 2: Prepare semantic-release arguments
        # =============================================================================
        ARGS=""
        if [ "${{ inputs.dry-run }}" = "true" ]; then
          ARGS="--dry-run"
        fi

        # =============================================================================
        # STEP 3: Prepare config file
        # We copy config to a temp file because:
        # - We may need to inject PyPI publish commands
        # - We don't want to modify user's config file
        # =============================================================================
        TEMP_CONFIG=".releaserc.semantic-release.json"

        if [ -n "${{ inputs.config-path }}" ]; then
          CONFIG_PATH="${{ inputs.config-path }}"
          if [[ "$CONFIG_PATH" != /* ]]; then
            CONFIG_SRC="$(pwd)/$CONFIG_PATH"
          else
            CONFIG_SRC="$CONFIG_PATH"
          fi
        else
          CONFIG_SRC="${{ github.action_path }}/.releaserc.json"
        fi

        cp "$CONFIG_SRC" "$TEMP_CONFIG"

        # =============================================================================
        # STEP 4: Enable PyPI publishing if requested (atomic release+publish)
        # =============================================================================
        if [ "${{ inputs.pypi-publish }}" = "true" ]; then
          if [ ! -d "${{ inputs.dist-directory }}" ]; then
            echo "::error::dist-directory '${{ inputs.dist-directory }}' does not exist. Ensure build-command creates this directory."
            exit 1
          fi

          if [ "${{ inputs.use-oidc }}" = "true" ]; then
            PUBLISH_CMD="uv publish --trusted-publishing always ${{ inputs.dist-directory }}/*"
          else
            PUBLISH_CMD="uv publish --token \$PYPI_TOKEN ${{ inputs.dist-directory }}/*"
          fi

          # Ensure @semantic-release/exec exists; append if missing, otherwise merge commands.
          jq --arg build "${{ inputs.build-command }}" --arg publish "$PUBLISH_CMD" '
            def add_exec:
              .plugins += [["@semantic-release/exec", {prepareCmd: $build, publishCmd: $publish}]];
            .plugins |= (
              if any(.[]; (type=="array" and .[0]=="@semantic-release/exec")) then
                map(
                  if type == "array" and .[0] == "@semantic-release/exec" then
                    [.[0], (.[1] // {}) + {
                      prepareCmd: ((.[1].prepareCmd // "") | if length > 0 then . + " && " + $build else $build end),
                      publishCmd: $publish
                    }]
                  else
                    .
                  end
                )
              else
                add_exec
              end
            )
          ' "$TEMP_CONFIG" > "$TEMP_CONFIG.tmp" && mv "$TEMP_CONFIG.tmp" "$TEMP_CONFIG"
        fi

        # =============================================================================
        # STEP 5: Run semantic-release
        # =============================================================================
        PREV_TAG=$(git describe --tags --abbrev=0 2>/dev/null || true)

        # Capture output and exit code (set +e prevents script from exiting on failure)
        set +e
        OUTPUT=$(npx --prefix "${{ github.action_path }}" semantic-release --extends "./$TEMP_CONFIG" $ARGS 2>&1)
        EXIT_CODE=$?
        set -e
        echo "$OUTPUT"

        rm -f "$TEMP_CONFIG"

        # =============================================================================
        # STEP 6: Set outputs
        # We detect new releases by comparing git tags before/after semantic-release
        # (more reliable than parsing semantic-release output)
        # =============================================================================
        NEW_TAG=$(git describe --tags --abbrev=0 2>/dev/null || true)
        if [ "$EXIT_CODE" -eq 0 ] && [ -n "$NEW_TAG" ] && [ "$NEW_TAG" != "$PREV_TAG" ]; then
          echo "new-release-published=true" >> $GITHUB_OUTPUT
          VERSION="${NEW_TAG#v}"
          echo "new-release-version=$VERSION" >> $GITHUB_OUTPUT
          echo "new-release-git-tag=$NEW_TAG" >> $GITHUB_OUTPUT
        else
          echo "new-release-published=false" >> $GITHUB_OUTPUT
          echo "new-release-version=" >> $GITHUB_OUTPUT
          echo "new-release-git-tag=" >> $GITHUB_OUTPUT
        fi

        exit $EXIT_CODE
