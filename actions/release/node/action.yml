name: Release Node Package
author: mrcointreau
description: Run semantic-release for Node.js packages. Set npm-publish=true for atomic release+publish (recommended). If npm fails, no tag/release is created

inputs:
  node-version:
    description: Node.js version
    required: false
    default: "22"
  working-directory:
    description: Working directory
    required: false
    default: "."
  bot-token:
    description: GitHub token for release
    required: true
  npm-token:
    description: NPM token for publishing, optional if using OIDC trusted publishing
    required: false
  dry-run:
    description: Run in dry-run mode
    required: false
    default: "false"
  use-oidc:
    description: Use OIDC trusted publishing (recommended), set to 'false' to use tokens
    required: false
    default: "true"
  config-path:
    description: Path to semantic-release config file (uses built-in config if empty)
    required: false
    default: ""
  npm-publish:
    description: Publish package to npm during release (atomic release+publish)
    required: false
    default: "false"
  build-command:
    description: Build command to run
    required: false
    default: "npm run build"
  dist-directory:
    description: Directory containing built package to publish (only used when npm-publish is true)
    required: false
    default: "dist"

outputs:
  new-release-published:
    description: Whether a new release was published ('true' or 'false')
    value: ${{ steps.release.outputs.new-release-published }}
  new-release-version:
    description: The new release version (if published)
    value: ${{ steps.release.outputs.new-release-version }}
  new-release-git-tag:
    description: The git tag of the new release (if published)
    value: ${{ steps.release.outputs.new-release-git-tag }}

runs:
  using: composite
  steps:
    - name: Setup Node.js
      uses: actions/setup-node@6044e13b5dc448c55e2357c09f80417699197238 # v6.2.0
      with:
        node-version: ${{ inputs.node-version }}
        registry-url: "https://registry.npmjs.org"

    - name: Install Dependencies
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      run: npm ci

    - name: Install semantic-release
      shell: bash
      working-directory: ${{ github.action_path }}
      run: npm ci

    - name: Build Package
      if: inputs.npm-publish == 'true'
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      run: ${{ inputs.build-command }}

    - name: Run semantic-release
      id: release
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      env:
        GITHUB_TOKEN: ${{ inputs.bot-token }}
        NPM_TOKEN: ${{ inputs.npm-token }}
        NODE_AUTH_TOKEN: ${{ inputs.npm-token }}
        NPM_CONFIG_PROVENANCE: ${{ inputs.use-oidc == 'true' && inputs.npm-token == '' && 'true' || '' }}
        NODE_PATH: ${{ github.action_path }}/node_modules
      run: |
        # =============================================================================
        # STEP 1: Validate authentication
        # OIDC is preferred (no token needed), but if disabled, npm-token is required
        # =============================================================================
        if [ "${{ inputs.dry-run }}" != "true" ] && [ "${{ inputs.use-oidc }}" != "true" ] && [ -z "${{ inputs.npm-token }}" ]; then
          echo "::error::npm-token is required when use-oidc is false (set NPM_TOKEN or run with dry-run)."
          exit 1
        fi

        # =============================================================================
        # STEP 2: Prepare semantic-release arguments
        # =============================================================================
        ARGS=""
        if [ "${{ inputs.dry-run }}" = "true" ]; then
          ARGS="--dry-run"
        fi

        # =============================================================================
        # STEP 3: Prepare config file
        # We copy config to a temp file because:
        # - We may need to inject pkgRoot for npm publishing
        # - We don't want to modify user's config file
        # =============================================================================
        TEMP_CONFIG=".releaserc.semantic-release.json"

        if [ -n "${{ inputs.config-path }}" ]; then
          # User provided custom config - resolve to absolute path
          CONFIG_PATH="${{ inputs.config-path }}"
          if [[ "$CONFIG_PATH" != /* ]]; then
            CONFIG_SRC="$(pwd)/$CONFIG_PATH"
          else
            CONFIG_SRC="$CONFIG_PATH"
          fi
        else
          # Use action's built-in config
          CONFIG_SRC="${{ github.action_path }}/.releaserc.json"
        fi

        cp "$CONFIG_SRC" "$TEMP_CONFIG"

        # =============================================================================
        # STEP 4: Configure npm publishing from dist directory (if enabled)
        # This enables atomic release: if npm publish fails, no git tag is created
        # =============================================================================
        if [ "${{ inputs.npm-publish }}" = "true" ]; then
          # Verify build output exists
          if [ ! -d "${{ inputs.dist-directory }}" ]; then
            echo "::error::dist-directory '${{ inputs.dist-directory }}' does not exist. Ensure build-command creates this directory."
            exit 1
          fi

          # Fallback: copy package.json if build didn't create one in dist
          # (Some builds create a minimal package.json, others don't - this handles both)
          if [ ! -f "${{ inputs.dist-directory }}/package.json" ]; then
            cp package.json "${{ inputs.dist-directory }}/"
          fi

          # Inject pkgRoot into @semantic-release/npm plugin config
          # This tells semantic-release to publish from dist/ instead of root
          # The jq command preserves any existing plugin options (like tarballDir) and forces npmPublish: true
          jq --arg dist "${{ inputs.dist-directory }}" '
            .plugins |= map(
              if (if type == "array" then .[0] else . end) == "@semantic-release/npm" then
                if type == "array" then
                  [.[0], (.[1] // {}) + {pkgRoot: $dist, npmPublish: true}]
                else
                  [., {pkgRoot: $dist, npmPublish: true}]
                end
              else
                .
              end
            )
          ' "$TEMP_CONFIG" > "$TEMP_CONFIG.tmp" && mv "$TEMP_CONFIG.tmp" "$TEMP_CONFIG"
        fi

        # =============================================================================
        # STEP 5: Run semantic-release
        # =============================================================================
        # Save current tag to detect if a new release was created
        PREV_TAG=$(git describe --tags --abbrev=0 2>/dev/null || true)

        # Capture output and exit code (set +e prevents script from exiting on failure)
        set +e
        OUTPUT=$(npx --prefix "${{ github.action_path }}" semantic-release --extends "./$TEMP_CONFIG" $ARGS 2>&1)
        EXIT_CODE=$?
        set -e
        echo "$OUTPUT"

        rm -f "$TEMP_CONFIG"

        # =============================================================================
        # STEP 6: Set outputs
        # We detect new releases by comparing git tags before/after semantic-release
        # (more reliable than parsing semantic-release output)
        # =============================================================================
        NEW_TAG=$(git describe --tags --abbrev=0 2>/dev/null || true)
        if [ "$EXIT_CODE" -eq 0 ] && [ -n "$NEW_TAG" ] && [ "$NEW_TAG" != "$PREV_TAG" ]; then
          echo "new-release-published=true" >> $GITHUB_OUTPUT
          VERSION="${NEW_TAG#v}"
          echo "new-release-version=$VERSION" >> $GITHUB_OUTPUT
          echo "new-release-git-tag=$NEW_TAG" >> $GITHUB_OUTPUT
        else
          echo "new-release-published=false" >> $GITHUB_OUTPUT
          echo "new-release-version=" >> $GITHUB_OUTPUT
          echo "new-release-git-tag=" >> $GITHUB_OUTPUT
        fi

        exit $EXIT_CODE
